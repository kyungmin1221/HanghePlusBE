#### 동시성: 여러 쓰레드가 동시에 실행되는 성질 , 동시에 공유변수에 접근해서 문제가 발생했기 때문에 동시성 문제라고 함
#### 동기화 문제 : 동시에 공유변수에 접근하였는데 문제가 되는 부분은 데이터 동기화이다. 동시에 쓰레드가 실행되는 과정 중 데이터가 꼬였기에 동기화에 문제가 있다고 본다. 

### ConcurrentHashMap
- 데이터가 빈번하게 변경되는 경우에 사용될 때는 큰 성능 이점을 보여줄 수 있다. 하지만 데이터 변경이 거의 없는 경우는 
CopyOnWriteArrayList 가 더 적합할 수 있다. 

- 동시성 문제 블로그 참고
< https://f-lab.kr/insight/solving-concurrency-in-java > 

### Synchronized   vs  ReentrantLock

#### Synchronized : 현재 데이터를 사용하고 있는 해당 스레드를 제외하고 나머지 스레드들은 데이터에 접근할 수 없도록 막는 개념
-> 자바의 Synchronized 는 스레드 동기화 시 사용하는 대표적 기법
-> Synchronized 가 붙은 키워드가 붙은 메서드를 사용하려면 락을 가지고 있어야함
-> 좋을까? : 성능저하를 불러올 수 있음 ( 왜? - 자바 내부적으로 메서드나 변수에 동기화를 하기 위해 블락과 언블락을 하는데 이런 처리들이 많아지면서 성능저하를 일으킬 수 있는 것) 

#### ReentrantLock
-> 특정 상태들에 대한 locking 을 관리하는 것을 볼 수 있음 
-> lock(), unlock() 으로 시작과 끝을 명시하기 때문에 여러 메서드에 나눠서 작성할 수 있음 
-> 명시적 : 메서드를 호출함으로써 어떤 스레드가 먼저 락을 획득하게 될건지 순서를 지정할 수 있음 

### < 공정성 > 
-> 공정한 락을 사용할 경우 경쟁이 발생했을 때 오래 기다린 쓰레드에게 락을 제공 ( Synchronized 는 공정성을 제공하지 않음 )
-> 즉, 공정성이라하면 모든 쓰레드가 자신의 작업을 수행할 기회를 모두 가진다라고 볼 수 있다.  공정한 방법에서는 큐 안에서 쓰레드들이 무조건 순서를 지키며 락을 획득한다. 불공정 방법에서는 만약 특정 쓰레드에 락이 필요한 순간 release 가 발생하면 대기열을 뛰어넘는 새치기가 발생한다. 다른 쓰레들에게 우선순위가 밀려 자원을 계속해서 할당받지 못하고 기다리는 쓰레드가 존재하는 상황을 기아상태 라고 부른다. 이러한 기아상태를 해결하기 위해서는 ‘공정성’ 이 필요한 것이다.  
